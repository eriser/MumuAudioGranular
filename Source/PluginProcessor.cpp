/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"


//==============================================================================
MumuAudioGranularAudioProcessor::MumuAudioGranularAudioProcessor() : grainp_ArrayL(nullptr),
                                                                     grainp_ArrayR(nullptr)
{
    m_GranulatorL = Granulator();
    m_GranulatorR = Granulator();
    
    m_gBufferL = GranularBuffer();
    m_gBufferR = GranularBuffer();
    
    m_SchedulerL = GrainScheduler();
    m_SchedulerR = GrainScheduler();
    
    //Float Parameters
    //Current Tab Bar Param
    addParameter(currentTab = new AudioParameterFloat("currentTabParam", "Tab", 0, 2, 0));
    //Tab 1 Param
    addParameter(Tab1_pitchKnobParam = new AudioParameterFloat("Tab1_pitchKnobParam", "Slider1", 0.0, 1.0, 0.5));
    addParameter(Tab1_densityKnobParam = new AudioParameterFloat("Tab1_densityKnobParam", "Slider2", 0.0, 1.0, 0.5));
    addParameter(Tab1_grainSizeKnobParam = new AudioParameterFloat("Tab1_grainSizeKnobParam", "Slider3", 0.0, 1.0, 0.5));
    addParameter(Tab1_dryWayKnobParam = new AudioParameterFloat("Tab1_dryWayKnobParam", "Slider4", 0.0, 1.0, 0.5));
    addParameter(Tab1_stretchSpeedKnobParam = new AudioParameterFloat("Tab1_stretchSpeedKnobParam", "Slider5", 0.0, 1.0, 0.5));
    //Bool Params
    //Tab 1 Param
    addParameter(Tab1_stretchButtonParam = new AudioParameterBool("Tab1_stretchButtonParam", "Button1" , 0));
    
    m_ADSR_Left_Started = 0;
    m_ADSR_Right_Started = 0;
}

MumuAudioGranularAudioProcessor::~MumuAudioGranularAudioProcessor()
{
    if(grainp_ArrayL)
        delete [] grainp_ArrayL;
    
    if(grainp_ArrayR)
        delete [] grainp_ArrayR;
}

//==============================================================================
const String MumuAudioGranularAudioProcessor::getName() const
{
    return JucePlugin_Name;
}

const String MumuAudioGranularAudioProcessor::getInputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

const String MumuAudioGranularAudioProcessor::getOutputChannelName (int channelIndex) const
{
    return String (channelIndex + 1);
}

bool MumuAudioGranularAudioProcessor::isInputChannelStereoPair (int index) const
{
    return true;
}

bool MumuAudioGranularAudioProcessor::isOutputChannelStereoPair (int index) const
{
    return true;
}

bool MumuAudioGranularAudioProcessor::acceptsMidi() const
{
   #if JucePlugin_WantsMidiInput
    return true;
   #else
    return false;
   #endif
}

bool MumuAudioGranularAudioProcessor::producesMidi() const
{
   #if JucePlugin_ProducesMidiOutput
    return true;
   #else
    return false;
   #endif
}

bool MumuAudioGranularAudioProcessor::silenceInProducesSilenceOut() const
{
    return false;
}

double MumuAudioGranularAudioProcessor::getTailLengthSeconds() const
{
    return 0.0;
}

int MumuAudioGranularAudioProcessor::getNumPrograms()
{
    return 1;   // NB: some hosts don't cope very well if you tell them there are 0 programs,
                // so this should be at least 1, even if you're not really implementing programs.
}

int MumuAudioGranularAudioProcessor::getCurrentProgram()
{
    return 0;
}

void MumuAudioGranularAudioProcessor::setCurrentProgram (int index)
{
}

const String MumuAudioGranularAudioProcessor::getProgramName (int index)
{
    return String();
}

void MumuAudioGranularAudioProcessor::changeProgramName (int index, const String& newName)
{
}

//==============================================================================
void MumuAudioGranularAudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    //std::cout << "prepare to play" << std::endl;
    m_fSampleRate = sampleRate;
    //Left Grains
    if (grainp_ArrayL)
        delete [] grainp_ArrayL;
    grainp_ArrayL = new Grain[m_nNumberGrains];
    //turn off all grains
    for (int i = 0; i < m_nNumberGrains; i++)
    {
        grainp_ArrayL[i].isBusy = 0;
    }
    //Right Grains
    if (grainp_ArrayR)
        delete [] grainp_ArrayR;
    grainp_ArrayR = new Grain[m_nNumberGrains];
    //turn off all grains
    for (int i = 0; i < m_nNumberGrains; i++)
    {
        grainp_ArrayR[i].isBusy = 0;
    }
    //set up grain buffers (audio data)
    m_gBufferL.setBufferLength(sampleRate, m_fMaxBufferLength);
    m_gBufferL.prepareToPlay();
    
    m_gBufferR.setBufferLength(sampleRate, m_fMaxBufferLength);
    m_gBufferR.prepareToPlay();
    //initialize Schedulers
    m_SchedulerL.prepareToPlay();
    m_SchedulerR.prepareToPlay();
    
    m_ADSR_Left.setSampleRate(m_fSampleRate);
    m_ADSR_Right.setSampleRate(m_fSampleRate);
    
}

void MumuAudioGranularAudioProcessor::releaseResources()
{
    
}

void MumuAudioGranularAudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midiMessages)
{
    //Clear Any Garbage Data
    for (int i = getNumInputChannels(); i < getNumOutputChannels(); ++i)
        buffer.clear (i, 0, buffer.getNumSamples());
    //Get Parameters
    updateParams();
    //Set Interonset Time
    m_SchedulerL.setInteronset(m_fSampleRate, density);
    m_SchedulerR.setInteronset(m_fSampleRate, density);
    //Parse Buffers And Process Samples
    for (int channel = 0; channel < getNumInputChannels(); ++channel)
    {
        float* channelData = buffer.getWritePointer (channel);
        
        for ( int i = 0; i < buffer.getNumSamples(); i++ )
        {
            if (channel == 0)
            {
                m_gBufferL.process(channelData[i]);
                m_SchedulerL.play();
                
                float output = m_GranulatorL.process( grainp_ArrayL, m_gBufferL, buttonState, m_SchedulerL.bang(), m_nNumberGrains, m_fSampleRate, grainSize, pitch, stretchSpeed );
                //std::cout << output << std::endl;
                channelData[i] = (output * dryWet) + ((1 - dryWet) * channelData[i]);
            }
            if (channel == 1)
            {
                m_gBufferR.process(channelData[i]);
                m_SchedulerR.play();

                float output = m_GranulatorR.process( grainp_ArrayR, m_gBufferR, buttonState, m_SchedulerR.bang(), m_nNumberGrains, m_fSampleRate, grainSize, pitch, stretchSpeed );

                channelData[i] = (output * dryWet) + ((1 - dryWet) * channelData[i]);
            }
        }
    }
//    std::shared_ptr<AudioSampleBuffer> newBuffer = std::make_shared<AudioSampleBuffer>(buffer);
//    std::atomic_store(&sharedSampleBuffer, newBuffer);
//    guiUpToDate.store(false);
//    std::cout << buttonState << std::endl;
}
//==============================================================================
bool MumuAudioGranularAudioProcessor::setPreferredBusArrangement(bool isInputBus, int busIndex, const juce::AudioChannelSet &preferredSet){
    const int numChannels = preferredSet.size();
    
    // we do not allow disabling any buses
    if (preferredSet == AudioChannelSet::disabled())
        return false;
    
    // only mono and stereo please
    if (numChannels > 2)
        return false;
    
    // always have the same channel layout on both input and output on the main bus
    if (! AudioProcessor::setPreferredBusArrangement (! isInputBus, busIndex, preferredSet))
        return false;
    
    // when accepting the layout we must fall through to the base class!
    return AudioProcessor::setPreferredBusArrangement (! isInputBus, busIndex, preferredSet);
}


//==============================================================================
bool MumuAudioGranularAudioProcessor::hasEditor() const
{
    return true; // (change this to false if you choose to not supply an editor)
}

AudioProcessorEditor* MumuAudioGranularAudioProcessor::createEditor()
{
    return new MumuAudioGranularAudioProcessorEditor (*this);
}

//==============================================================================
void MumuAudioGranularAudioProcessor::getStateInformation (MemoryBlock& destData)
{
    // You should use this method to store your parameters in the memory block.
    // You could do that either as raw data, or use the XML or ValueTree classes
    // as intermediaries to make it easy to save and load complex data.
}

void MumuAudioGranularAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    // You should use this method to restore your parameters from this memory block,
    // whose contents will have been created by the getStateInformation() call.
}

//==============================================================================
void MumuAudioGranularAudioProcessor::updateParams(){
     pitch = jmap(Tab1_pitchKnobParam->getValue(), 0.001f, 2.0f);
     density = jmap(Tab1_densityKnobParam->getValue(), 0.015f, 0.6f);
     grainSize = jmap(Tab1_grainSizeKnobParam->getValue(), 0.01f, 0.5f);
     dryWet = Tab1_dryWayKnobParam->getValue();
     buttonState = Tab1_stretchButtonParam->getValue();
     stretchSpeed = Tab1_stretchSpeedKnobParam->getValue();
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new MumuAudioGranularAudioProcessor();
}
